

iniate
	choosePattern
	add to route
	set legnum to 0

pilot
	if not moving
		set throttle
	compare position
	if position reached:
		legnum += 1
	if line:
		compare heading to bearing
		if off:
			set helm
	if arc:
		compare time to eta
		if past:
			legnum += 1
		


def navigate():
	jlog.debug(f'skate: navigate')
	if route almost finished or no route at all:
		legs = choosePattern()
		add legs to route
		current leg = 

----------------

cones[] - 2D array of x,y points
plan - cones, order, sides
route 

placeCones() -> cones[] a 2D array of x,y points within the arena
planRoute(cones) -> order, sides
	input - cones array
	output - order: array of cone numbers, sides: array of strings, 'ccw' or 'cw'


plan = calcPlan(cones, order, sides)
	output plan is list of dicts, sorted by order
		each dict 
			order
			center
			rdir
			entry
			exit

route = plotRoute(plan)
		each dict
			shape line
			from point
			to point
			bearing
		or
			shape arc
			from point
			to point
			center point
			rdir rotation direction cw or ccw


list of [conenum, side] in order
for execution, add entry and exit points


save center from donut
	special op
	save to disk, then shutdown
	mode, like sim

throttle adjustment is relative to roll, not helm
	therefore, perhaps we should go back to separate commands
	if doing async, we need events
		onRoll - adjust throttle depending on roll
		onHeading - adjust helm to keep course bearing and/or turn radius
		onPosition - override dead-reckoning position
----------------------

Pilot
        Run through a stack of legs
        If heading not = bearing, helm
        Else helm 0
        If dest = position, next leg
        If time we'll past eta, kill
        When starting leg, calc eta
        Add start, stop to leg
        Stop is eta until completed
        If next dest reached
                Bump to next leg

Navigate
        Stack of legs
        Stack of ahrs
        When stack full, save and clear

        On donut
                Set center
                        Three offsets: 0, 90, -90

-------------

Do all positions in cm, With 0,0 at the arena center

Go to point (two legs: 1 arc, 1 line)
        Calc two angles
        Choose the smaller
        Full arc
        Line to dest

On roll
        Dead reckon


--------------------------------



'''
	throttle : speed : distance : roll adjustment
	helm : arm angle : roll
	roll : turning radius : axle angle : outer wheel speed : inner wheel speed
	roll : deck center : wheelbase center

	distance: cm, px, cm:px
	speed: cm/sec, px/sec

	angular velocity

https://www.geogebra.org/geometry/w3kqwan9
	turning radius inner = 23 - 8.25 = 14.75 * 2pi =  92.67 = circum
	turning radius center            = 23.00 * 2pi = 144.51
	turning radius outer = 23 + 8.25 = 31.25 * 2pi = 196.35

inner_circum  =  92.67 # cm
center_circum = 144.51 # cm
outer_circum  = 196.35 # cm

# motor is on right rear wheel

# at throttle 23, speed is 144 cm/ n secs

# for one full circle
# wheel circum 17
# at right turn,    right wheel outer rim travels  92 cm,  92/17 =  5.4 revs
# on straight-away, right wheel outer rim travels 144 cm, 144/17 =  8.5 revs 
# at left turn,     right wheel outer rim travels 196 cm, 196/17 = 11.5 revs

#  5.4/8.5
# 11.5/8.5

# (144-92)/144 = .361
# (196-144)/144 = .361
# ( 8.5-5.4)/8.5 = .365
# (11.5-8.5)/8.5 = .353

# percent farther in the same time period


ctrWheelbase	(x,y)

def wheelbaseFromDonut(x,y):
	return x,y



throttle interpolate

input -100 to +100
output 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,35,36,38,40

if input <= 3
	output = 0
else
	factor = 40 to 100
	output = input -3 * factor

throttle is always set to 50%
adjusted can be 0 or 4 to 43


https://calculator.academy/turning-radius-calculator/


-----------------------
# throttle

# percent throttle: -100 to +100

int throttle  =  0;  // positive: ahead, negative: astern
int adjusted  =  0;  // throttle adjusted for helm position

const int aheadSlow =  3;   // throttle examples: 0,1,2 full stop
const int aheadHalf = 23;   // 23 -  3 = 20, 20/2 = 10 steps 
const int aheadFull = 43;   // 43 - 23 = 20
const int throttleInc =  2;     // reasonable increment throttle steps

# helm degrees -90 to +90
int helm = 0;  // positive: starboard, negative: port
int helmDesired = 0;
const int portFull = -90;
const int portHalf = -45;
const int portSlow =  -5;
const int starboardFull = 90;

const int starboardHalf = 45;
const int starboardSlow =  5;
const int helmAmidships =  0;

const int helmSweepInc = 2;
const int helmStepInc = 5;
const int helmPause = 10;
'''

'''
pid controller
PV process variable, roll
r(t) = set point: 0
y(t) = measurement: ahrs.roll
e(t) = error: r(t) - y(t)
u(t) = control variable, output: helm, set to weighted sum of P,I,D
Kp = proportional 
Ki = integral
Kd = derivative

P = Kp * e(t)

CV = u = (Kp * error) + (Kd * (dError / dt)) + (Ki * areaError  (area + (Error * dt))

currently, vehicle has consistent list to starboard
task 1: find helm offset that results in a straight line

non-zero rudder results in steadily changing heading
zero rudder = helm + helm_offset

user wants to think helm is at zero, actually it is at the offset
if offset is 2, helm must be 2 to keep rudder at zero

helm offset => zero rudder => straight line



rudder_angle = axle_angle * 2
deck_angle  and rudder angle are remarkably close

axle is mounted at 45 degrees
straight-ahead, axle is perpendicular to deck
deck angle 19 => axle angle 10

direct connection between roll and rudder
roll = deck_angle
rudder = axle_angle * 2
rudder affects heading
helm throws the weight

roll:rudder interpolation
19:20
consideer it 20:20, ie 1:1


when going straight, we want the rudder at 0
if roll is 10
	bring it back to zero

PID step 1, keep rudder at 0
PID step 2, keep heading at bearing, both change with vehicle position

'''
